from aiogram import Router, typesfrom aiogram.filters import Command, CommandObject, Filterfrom aiogram.types import Message# Импорт модуля работы с базой данныхfrom app.database import sqlite_dbadmin = Router()ADMIN_ID = [2015462319]  # список ID администраторовclass AdminProtect(Filter):    def __init__(self):        self.admins = ADMIN_ID    async def __call__(self, message: types.Message) -> bool:        return message.from_user.id in self.admins# Вспомогательная функция для определения типа содержимого и извлечения file_iddef detect_content(message: Message, command: CommandObject):    caption = command.args or ""    if message.photo:        return "photo", message.photo[-1].file_id, caption    elif message.video:        return "video", message.video.file_id, caption    elif message.document:        return "document", message.document.file_id, caption    elif message.audio:        return "audio", message.audio.file_id, caption    elif message.voice:        return "voice", message.voice.file_id, caption    else:        return "text", None, caption# ------------------------------------------------------------------------------# Команда рассылки для гостей (на основе таблицы guest_cards)@admin.message(AdminProtect(), Command("send_guest"))async def send_guest(message: Message, command: CommandObject):    content_type, file_id, caption = detect_content(message)    guest_cards = sqlite_db.get_all_guest_cards()  # структура: (id, tg_id, name, phone, photo, food, alerg)    count = 0    for card in guest_cards:        tg_id = card[1]        try:            if content_type == "text":                await message.bot.send_message(tg_id, caption)            elif content_type == "photo":                await message.bot.send_photo(tg_id, photo=file_id, caption=caption)            elif content_type == "video":                await message.bot.send_video(tg_id, video=file_id, caption=caption)            elif content_type == "document":                await message.bot.send_document(tg_id, document=file_id, caption=caption)            elif content_type == "audio":                await message.bot.send_audio(tg_id, audio=file_id, caption=caption)            elif content_type == "voice":                await message.bot.send_voice(tg_id, voice=file_id, caption=caption)            count += 1        except Exception as e:            print(f"Ошибка при отправке сообщения гостю с id {tg_id}: {e}")    await message.answer(f"Сообщение отправлено {count} гостям.")# ------------------------------------------------------------------------------# Вспомогательная функция для получения списка TG_ID официантовdef get_all_waiters():    sqlite_db.cur.execute("SELECT tg_id FROM waiters")    rows = sqlite_db.cur.fetchall()    return [row[0] for row in rows]# Команда рассылки для официантов (таблица waiters)@admin.message(AdminProtect(), Command("send_waiters"))async def send_waiters(message: Message, command: CommandObject):    content_type, file_id, caption = detect_content(message)    waiter_ids = get_all_waiters()    count = 0    for tg_id in waiter_ids:        try:            if content_type == "text":                await message.bot.send_message(tg_id, caption)            elif content_type == "photo":                await message.bot.send_photo(tg_id, photo=file_id, caption=caption)            elif content_type == "video":                await message.bot.send_video(tg_id, video=file_id, caption=caption)            elif content_type == "document":                await message.bot.send_document(tg_id, document=file_id, caption=caption)            elif content_type == "audio":                await message.bot.send_audio(tg_id, audio=file_id, caption=caption)            elif content_type == "voice":                await message.bot.send_voice(tg_id, voice=file_id, caption=caption)            count += 1        except Exception as e:            print(f"Ошибка при отправке сообщения официанту с id {tg_id}: {e}")    await message.answer(f"Сообщение отправлено {count} официантам.")# ------------------------------------------------------------------------------# Команда общей рассылки (на основе таблицы users_start)@admin.message(AdminProtect(), Command("broadcast"))async def broadcast(message: Message, command: CommandObject):    content_type, file_id, caption = detect_content(message)    users = sqlite_db.get_all_starts()  # структура: (id, tg_id, username, start_date)    count = 0    for user in users:        tg_id = user[1]        try:            if content_type == "text":                await message.bot.send_message(tg_id, caption)            elif content_type == "photo":                await message.bot.send_photo(tg_id, photo=file_id, caption=caption)            elif content_type == "video":                await message.bot.send_video(tg_id, video=file_id, caption=caption)            elif content_type == "document":                await message.bot.send_document(tg_id, document=file_id, caption=caption)            elif content_type == "audio":                await message.bot.send_audio(tg_id, audio=file_id, caption=caption)            elif content_type == "voice":                await message.bot.send_voice(tg_id, voice=file_id, caption=caption)            count += 1        except Exception as e:            print(f"Ошибка при отправке сообщения пользователю с id {tg_id}: {e}")    await message.answer(f"Сообщение отправлено {count} пользователям.")@admin.message(Command("get_test_results"))async def get_test_results(message: Message):    results = sqlite_db.get_all_test_results_with_username()  # получаем данные с именем пользователя    if not results:        await message.answer("Результаты тестирования пока отсутствуют.")        return    text = "Результаты тестирования:\n\n"    # Каждая строка имеет структуру: (result_id, tg_id, username, score, total, timestamp)    for row in results:        result_id, tg_id, username, score, total, timestamp = row        text += (            f"ID: {result_id}, TG_ID: {tg_id}, USERNAME: {username}, "            f"Результат: {score}/{total}, Дата: {timestamp}\n"        )    await message.answer(text)@admin.message(Command("clear_test_results"))async def clear_test_results_handler(message: Message):    count = sqlite_db.clear_test_results()  # Удаляем результаты и получаем количество удалённых записей    await message.answer(f"Результаты тестирования успешно очищены. Удалено записей: {count}")