import osfrom aiogram import Router, types, Ffrom aiogram.filters import Command, Filter, CommandObjectfrom aiogram.fsm.context import FSMContextfrom aiogram.fsm.state import StatesGroup, Statefrom aiogram.types import Message, FSInputFile# Импорт модуля работы с базой данныхfrom app.database import sqlite_dbfrom app.video_converter import convert_to_videonoteadmin = Router()ADMIN_ID = [2015462319, 1773695867]  # список ID администраторовclass AdminProtect(Filter):    def __init__(self):        self.admins = ADMIN_ID    async def __call__(self, message: types.Message) -> bool:        return message.from_user.id in self.admins# Класс состояний для команды /test_noteclass TestNoteStates(StatesGroup):    waiting_for_video = State()@admin.message(Command("test_note"))async def cmd_test_note(message: Message, state: FSMContext):    """    Обработчик команды /test_note:    Ставит пользователя в состояние ожидания видео для конвертации.    """    await message.answer("Пожалуйста, отправьте видео для конвертации в видеосообщение.")    await state.set_state(TestNoteStates.waiting_for_video)@admin.message(TestNoteStates.waiting_for_video, F.content_type == "video")async def process_video(message: Message, state: FSMContext):    """    Обрабатывает видео от пользователя, конвертирует его и отправляет    как video_note.    """    if not message.video:        await message.answer("Отправьте, пожалуйста, видео.")        return    # Получаем file_id видео и скачиваем файл через бота    file_id = message.video.file_id    file_info = await message.bot.get_file(file_id)    input_path = "user_video.mp4"    await message.bot.download_file(file_info.file_path, destination=input_path)    output_path = "video_note.mp4"    try:        convert_to_videonote(input_path, output_path, size=360)    except Exception as e:        await message.answer(f"Ошибка конвертации видео: {e}")        await state.clear()        return    if not os.path.exists(output_path):        await message.answer("Ошибка: видео не сконвертировалось.")    else:        # Передаём путь к файлу напрямую в FSInputFile        file = FSInputFile(output_path, filename="video_note.mp4")        await message.answer_video_note(video_note=file)    # Очищаем состояние    await state.clear()    # Удаляем временные файлы    try:        os.remove(input_path)        os.remove(output_path)    except Exception:        pass# Вспомогательная функция для определения типа содержимого и извлечения file_iddef detect_content(message: Message, command: CommandObject):    caption = command.args or ""    if message.photo:        return "photo", message.photo[-1].file_id, caption    elif message.video:        return "video", message.video.file_id, caption    elif message.document:        return "document", message.document.file_id, caption    elif message.audio:        return "audio", message.audio.file_id, caption    elif message.voice:        return "voice", message.voice.file_id, caption    else:        return "text", None, caption# ------------------------------------------------------------------------------# Команда рассылки для гостей (на основе таблицы guest_cards)@admin.message(AdminProtect(), Command("send_guest"))async def send_guest(message: Message, command: CommandObject):    content_type, file_id, caption = detect_content(message)    guest_cards = sqlite_db.get_all_guest_cards()  # структура: (id, tg_id, name, phone, photo, food, alerg)    count = 0    for card in guest_cards:        tg_id = card[1]        try:            if content_type == "text":                await message.bot.send_message(tg_id, caption)            elif content_type == "photo":                await message.bot.send_photo(tg_id, photo=file_id, caption=caption)            elif content_type == "video":                await message.bot.send_video(tg_id, video=file_id, caption=caption)            elif content_type == "document":                await message.bot.send_document(tg_id, document=file_id, caption=caption)            elif content_type == "audio":                await message.bot.send_audio(tg_id, audio=file_id, caption=caption)            elif content_type == "voice":                await message.bot.send_voice(tg_id, voice=file_id, caption=caption)            count += 1        except Exception as e:            print(f"Ошибка при отправке сообщения гостю с id {tg_id}: {e}")    await message.answer(f"Сообщение отправлено {count} гостям.")# ------------------------------------------------------------------------------# Вспомогательная функция для получения списка TG_ID официантовdef get_all_waiters():    sqlite_db.cur.execute("SELECT tg_id FROM waiters")    rows = sqlite_db.cur.fetchall()    return [row[0] for row in rows]# Команда рассылки для официантов (таблица waiters)@admin.message(AdminProtect(), Command("send_waiters"))async def send_waiters(message: Message, command: CommandObject):    content_type, file_id, caption = detect_content(message)    waiter_ids = get_all_waiters()    count = 0    for tg_id in waiter_ids:        try:            if content_type == "text":                await message.bot.send_message(tg_id, caption)            elif content_type == "photo":                await message.bot.send_photo(tg_id, photo=file_id, caption=caption)            elif content_type == "video":                await message.bot.send_video(tg_id, video=file_id, caption=caption)            elif content_type == "document":                await message.bot.send_document(tg_id, document=file_id, caption=caption)            elif content_type == "audio":                await message.bot.send_audio(tg_id, audio=file_id, caption=caption)            elif content_type == "voice":                await message.bot.send_voice(tg_id, voice=file_id, caption=caption)            count += 1        except Exception as e:            print(f"Ошибка при отправке сообщения официанту с id {tg_id}: {e}")    await message.answer(f"Сообщение отправлено {count} официантам.")# ------------------------------------------------------------------------------# Команда общей рассылки (на основе таблицы users_start)@admin.message(AdminProtect(), Command("broadcast"))async def broadcast(message: Message, command: CommandObject):    content_type, file_id, caption = detect_content(message)    users = sqlite_db.get_all_starts()  # структура: (id, tg_id, username, start_date)    count = 0    for user in users:        tg_id = user[1]        try:            if content_type == "text":                await message.bot.send_message(tg_id, caption)            elif content_type == "photo":                await message.bot.send_photo(tg_id, photo=file_id, caption=caption)            elif content_type == "video":                await message.bot.send_video(tg_id, video=file_id, caption=caption)            elif content_type == "document":                await message.bot.send_document(tg_id, document=file_id, caption=caption)            elif content_type == "audio":                await message.bot.send_audio(tg_id, audio=file_id, caption=caption)            elif content_type == "voice":                await message.bot.send_voice(tg_id, voice=file_id, caption=caption)            count += 1        except Exception as e:            print(f"Ошибка при отправке сообщения пользователю с id {tg_id}: {e}")    await message.answer(f"Сообщение отправлено {count} пользователям.")@admin.message(Command("get_test_results"))async def get_test_results(message: Message):    results = sqlite_db.get_all_test_results_with_username()  # получаем данные с именем пользователя    if not results:        await message.answer("Результаты тестирования пока отсутствуют.")        return    text = "Результаты тестирования:\n\n"    # Каждая строка имеет структуру: (result_id, tg_id, username, score, total, timestamp)    for row in results:        result_id, tg_id, username, score, total, timestamp = row        text += (            f"ID: {result_id}, TG_ID: {tg_id}, USERNAME: {username}, "            f"Результат: {score}/{total}, Дата: {timestamp}\n"        )    await message.answer(text)@admin.message(Command("clear_test_results"))async def clear_test_results_handler(message: Message):    count = sqlite_db.clear_test_results()  # Удаляем результаты и получаем количество удалённых записей    await message.answer(f"Результаты тестирования успешно очищены. Удалено записей: {count}")