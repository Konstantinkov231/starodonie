import osfrom io import BytesIOfrom aiogram import Router, Ffrom aiogram.filters import Command, CommandObject, Filterfrom aiogram.fsm.context import FSMContextfrom aiogram.fsm.state import StatesGroup, Statefrom aiogram.types import (    Message,    CallbackQuery,    FSInputFile,    InlineKeyboardMarkup,    InlineKeyboardButton,)from openpyxl import Workbookfrom app.database.sqlite_db import (    get_all_guest_cards,    get_all_waiters,    get_all_starts,    add_shift,    set_shift_hours,    get_all_shifts,    clear_test_results,    get_all_test_results_with_username,)from app.video_converter import convert_to_videonoteadmin = Router()# --- Настройки админов ---ADMIN_ID = [2015462319, 1773695867]  # список ID администраторовdef user_is_admin(user_id: int) -> bool:    return user_id in ADMIN_IDclass AdminProtect(Filter):    async def __call__(self, message: Message) -> bool:        return user_is_admin(message.from_user.id)# Состояния для видео-конвертации (/test_note)class TestNoteStates(StatesGroup):    waiting_for_video = State()# Состояния для ввода часов (/add_shift flow)class ShiftAdminStates(StatesGroup):    waiting_hours = State()# ----------------------------------------------------------------------------# Утилита: определение типа содержимого для рассылок# ----------------------------------------------------------------------------def detect_content(message: Message, command: CommandObject):    caption = command.args or ""    if message.photo:        return "photo", message.photo[-1].file_id, caption    if message.video:        return "video", message.video.file_id, caption    if message.document:        return "document", message.document.file_id, caption    if message.audio:        return "audio", message.audio.file_id, caption    if message.voice:        return "voice", message.voice.file_id, caption    return "text", None, caption# ----------------------------------------------------------------------------# /test_note — конвертация видео в video_note# ----------------------------------------------------------------------------@admin.message(Command("test_note"), AdminProtect())async def cmd_test_note(message: Message, state: FSMContext):    await message.answer("Пожалуйста, отправьте видео для конвертации в видеосообщение.")    await state.set_state(TestNoteStates.waiting_for_video)@admin.message(TestNoteStates.waiting_for_video, F.content_type=="video", AdminProtect())async def process_video(message: Message, state: FSMContext):    file_id = message.video.file_id    file_info = await message.bot.get_file(file_id)    input_path = "user_video.mp4"    await message.bot.download_file(file_info.file_path, destination=input_path)    output_path = "video_note.mp4"    try:        convert_to_videonote(input_path, output_path, size=360)    except Exception as e:        await message.answer(f"Ошибка конвертации видео: {e}")        await state.clear()        return    if os.path.exists(output_path):        await message.answer_video_note(video_note=FSInputFile(output_path))    else:        await message.answer("Ошибка: видео не сконвертировалось.")    await state.clear()    for p in (input_path, output_path):        try:            os.remove(p)        except OSError:            pass# ----------------------------------------------------------------------------# Рассылки# ----------------------------------------------------------------------------@admin.message(AdminProtect(), Command("send_guest"))async def send_guest(message: Message, command: CommandObject):    content_type, file_id, caption = detect_content(message, command)    cards = get_all_guest_cards()    count = 0    for _, tg_id, *_ in cards:        try:            if content_type == "text":                await message.bot.send_message(tg_id, caption)            elif content_type == "photo":                await message.bot.send_photo(tg_id, file_id, caption)            elif content_type == "video":                await message.bot.send_video(tg_id, file_id, caption)            elif content_type == "document":                await message.bot.send_document(tg_id, file_id, caption)            elif content_type == "audio":                await message.bot.send_audio(tg_id, file_id, caption)            elif content_type == "voice":                await message.bot.send_voice(tg_id, file_id, caption)            count += 1        except:            pass    await message.answer(f"Сообщение отправлено {count} гостям.")@admin.message(AdminProtect(), Command("send_waiters"))async def send_waiters(message: Message, command: CommandObject):    content_type, file_id, caption = detect_content(message, command)    ids = get_all_waiters()    count = 0    for tg_id in ids:        try:            if content_type == "text":                await message.bot.send_message(tg_id, caption)            elif content_type == "photo":                await message.bot.send_photo(tg_id, file_id, caption)            elif content_type == "video":                await message.bot.send_video(tg_id, file_id, caption)            elif content_type == "document":                await message.bot.send_document(tg_id, file_id, caption)            elif content_type == "audio":                await message.bot.send_audio(tg_id, file_id, caption)            elif content_type == "voice":                await message.bot.send_voice(tg_id, file_id, caption)            count += 1        except:            pass    await message.answer(f"Сообщение отправлено {count} официантам.")@admin.message(AdminProtect(), Command("broadcast"))async def broadcast(message: Message, command: CommandObject):    content_type, file_id, caption = detect_content(message, command)    users = get_all_starts()    count = 0    for _, tg_id, *_ in users:        try:            if content_type == "text":                await message.bot.send_message(tg_id, caption)            elif content_type == "photo":                await message.bot.send_photo(tg_id, file_id, caption)            elif content_type == "video":                await message.bot.send_video(tg_id, file_id, caption)            elif content_type == "document":                await message.bot.send_document(tg_id, file_id, caption)            elif content_type == "audio":                await message.bot.send_audio(tg_id, file_id, caption)            elif content_type == "voice":                await message.bot.send_voice(tg_id, file_id, caption)            count += 1        except:            pass    await message.answer(f"Сообщение отправлено {count} пользователям.")# ----------------------------------------------------------------------------# Тест-результаты@admin.message(AdminProtect(), Command("get_test_results"))async def get_test_results(message: Message):    results = get_all_test_results_with_username()    if not results:        return await message.answer("Результаты тестирования пока отсутствуют.")    text = "Результаты тестирования:\n"    for rid, tg, uname, score, tot, ts in results:        text += f"ID:{rid}, TG:{tg}, USER:{uname}, {score}/{tot} ({ts})\n"    await message.answer(text)@admin.message(AdminProtect(), Command("clear_test_results"))async def clear_tests(message: Message):    removed = clear_test_results()    await message.answer(f"Удалено записей: {removed}")# ----------------------------------------------------------------------------# Управление сменами@admin.message(AdminProtect(), Command("add_shift"))async def cmd_add_shift(message: Message):    buttons = []    for wid, name in get_all_waiters():        buttons.append(InlineKeyboardButton(text=name or str(wid), callback_data=f"AS_W|{wid}"))    kb = InlineKeyboardMarkup(row_width=2, inline_keyboard=[buttons])    await message.answer("Выберите официанта:", reply_markup=kb)@admin.callback_query(AdminProtect(), F.data.startswith("AS_W"))async def process_waiter_select(query: CallbackQuery, state: FSMContext):    _, wid = query.data.split("|")    wid = int(wid)    await query.message.delete()    from app.utils.calendar import make_calendar    from datetime import datetime    kb = make_calendar(datetime.today().year, datetime.today().month, set())    await query.message.answer("Теперь выберите дату:", reply_markup=kb)    await state.update_data(admin_shift={"waiter_id": wid})@admin.callback_query(AdminProtect(), F.data.startswith("CAL_DAY"))async def admin_choose_date(query: CallbackQuery, state: FSMContext):    _, date_str = query.data.split("|")    data = await state.get_data()    wid = data["admin_shift"]["waiter_id"]    add_shift(wid, date_str)    await query.message.edit_text(f"Смена на {date_str} добавлена. Введите, пожалуйста, количество часов:")    await state.update_data(admin_shift={"waiter_id": wid, "date_str": date_str})    await state.set_state(ShiftAdminStates.waiting_hours)@admin.message(ShiftAdminStates.waiting_hours, AdminProtect())async def process_hours(message: Message, state: FSMContext):    txt = message.text.replace(",", ".").strip()    try:        hrs = float(txt)    except ValueError:        return await message.answer("Нужно число. Попробуйте ещё раз.")    data = await state.get_data()    wid = data["admin_shift"]["waiter_id"]    date_str = data["admin_shift"]["date_str"]    set_shift_hours(wid, date_str, hrs)    await message.answer(f"Часы сохранены: {hrs} ч.")    await state.clear()# ----------------------------------------------------------------------------# Экспорт смен в Excel@admin.message(AdminProtect(), Command("export_shifts"))async def cmd_export_shifts(message: Message):    rows = get_all_shifts()    wb = Workbook()    ws = wb.active    ws.append(["Официант", "Дата", "Часы"])    for name, date_str, hrs in rows:        ws.append([name, date_str, hrs])    bio = BytesIO()    wb.save(bio)    bio.seek(0)    await message.answer_document(FSInputFile(bio, filename="shifts.xlsx"))