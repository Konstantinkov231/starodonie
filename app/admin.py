"""Admin-side handlers for «Стародонье»-бота."""from __future__ import annotationsimport calendarimport osfrom datetime import datetime, timedeltafrom io import BytesIOfrom typing import Optional, Set, Tuplefrom aiogram import Router, Ffrom aiogram.filters import Command, Filter, StateFilterfrom aiogram.fsm.context import FSMContextfrom aiogram.fsm.state import StatesGroup, Statefrom aiogram.types import (    CallbackQuery,    FSInputFile,    InlineKeyboardButton,    InlineKeyboardMarkup,    Message,)from openpyxl import Workbookfrom app.database import sqlite_db# ────────────────────────────# DB helpers# ────────────────────────────from app.database.sqlite_db import (    add_shift,    get_all_shifts,    get_all_waiters,    get_waiter_by_tg,    set_shift_hours,    set_shift_tasks,)cur = Nonedef get_cursor():    """    Возвращает рабочий cursor SQLite.    * Если соединение ещё не создано (sqlite_db.base is None),      автоматически вызываем sql_start().    * Каждый вызов берёт cursor() заново — так избегаем проблем      с закрытыми курсорами.    """    if sqlite_db.base is None:        sqlite_db.sql_start()          # инициализация БД «на лету»    return sqlite_db.base.cursor()async def _safe_delete_message(bot, chat_id: int, msg_id: Optional[int]):    if msg_id:        try:            await bot.delete_message(chat_id, msg_id)        except Exception:            passdef _format_payline(*args) -> Tuple[str, float]:    """Формирует строку расчёта: (date, hrs, rate) или (name, date, hrs, rate)."""    if len(args) == 3:        date, hrs, rate = args        if hrs is None:            return f"• {date}: —", 0.0        pay = hrs * rate        return f"• {date}: {hrs:.2f} ч × {rate} = {pay:.2f}", pay    elif len(args) == 4:        name, date, hrs, rate = args        if hrs is None:            return f"{name} {date}: —", 0.0        pay = hrs * rate        return f"{name} {date}: {hrs:.2f} ч × {rate} = {pay:.2f}", pay    raise TypeError("_format_payline expects 3 or 4 args")# ────────────────────────────# Router & guard# ────────────────────────────admin = Router()ADMIN_IDS = [2015462319, 1773695867]class AdminProtect(Filter):    async def __call__(self, event) -> bool:        user = getattr(event, "from_user", None)        return bool(user and user.id in ADMIN_IDS)# ────────────────────────────# UI helpers# ────────────────────────────KB_BACK_MENU = InlineKeyboardMarkup(    inline_keyboard=[[InlineKeyboardButton(text="⏪ В меню админа", callback_data="AM_BACK_MENU")]])def make_calendar(year: int, month: int, marked: Set[str]) -> InlineKeyboardMarkup:    kb: list[list[InlineKeyboardButton]] = []    kb.append([        InlineKeyboardButton(text="‹", callback_data=f"CAL_PREV|{year}|{month}"),        InlineKeyboardButton(text=f"{calendar.month_name[month]} {year}", callback_data="IGNORE"),        InlineKeyboardButton(text="›", callback_data=f"CAL_NEXT|{year}|{month}"),    ])    kb.append([        InlineKeyboardButton(text=d, callback_data="IGNORE")        for d in ["Пн","Вт","Ср","Чт","Пт","Сб","Вс"]    ])    for week in calendar.Calendar(firstweekday=0).monthdayscalendar(year, month):        row = []        for day in week:            if day == 0:                row.append(InlineKeyboardButton(text=" ", callback_data="IGNORE"))            else:                ds = f"{year:04d}-{month:02d}-{day:02d}"                mark = "✓" if ds in marked else ""                row.append(InlineKeyboardButton(text=f"{day}{mark}", callback_data=f"CAL_DAY|{ds}"))        kb.append(row)    kb.append([InlineKeyboardButton(text="❌ Отмена", callback_data="CAL_CANCEL")])    kb.append([InlineKeyboardButton(text="🧹 Очистить месяц", callback_data="AM_CLEAR_SCHEDULE")])    return InlineKeyboardMarkup(inline_keyboard=kb)# ────────────────────────────# FSM states# ────────────────────────────class EditSchedStates(StatesGroup):    ChooseDate = State()    ChooseWaiter = State()    ChooseTaskAction = State()    InputPersonalTasks = State()class SetHoursStates(StatesGroup):    ChooseWaiter = State()    ChooseDate = State()    InputStartTime = State()    InputEndTime = State()# ────────────────────────────# IGNORE# ────────────────────────────@admin.callback_query(F.data == "IGNORE")async def _ignore(query: CallbackQuery): await query.answer()# ────────────────────────────# MAIN MENU# ────────────────────────────@admin.message(Command("admin_menu"), AdminProtect())async def admin_menu(message: Message, state: FSMContext):    await state.clear()    kb = InlineKeyboardMarkup(inline_keyboard=[        [InlineKeyboardButton(text="🗓 Изменить график", callback_data="AM_EDIT_SCHEDULE")],        [InlineKeyboardButton(text="🕒 Установить часы",  callback_data="AM_SET_HOURS")],        [InlineKeyboardButton(text="💰 Рассчитать зарплату", callback_data="AM_CALC_SALARY")],        [InlineKeyboardButton(text="📢 Информировать",    callback_data="AM_NOTIFY")],        [InlineKeyboardButton(text="📥 Скачать Excel",    callback_data="AM_EXPORT")],    ])    await message.answer("<b>Меню администратора</b>", parse_mode="HTML", reply_markup=kb)# ――― остальные хэндлеры (Set hours, Edit schedule, Salary, Export…) остаются#     exactly такими же, как в предыдущем сообщении. Скопируйте их без изменений.# ─────────────────────────────────────────────#   SET HOURS block (complete)# ─────────────────────────────────────────────@admin.callback_query(AdminProtect(), F.data == "AM_SET_HOURS")async def sh_start(query: CallbackQuery, state: FSMContext):    await state.clear()    buttons = [        [            InlineKeyboardButton(                text=(get_waiter_by_tg(tg)[1] or str(tg)), callback_data=f"SH_WAITER|{tg}"            )        ]        for tg in get_all_waiters()    ]    await state.set_state(SetHoursStates.ChooseWaiter)    await query.message.edit_text(        "Выберите сотрудника для установки часов:",        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons),    )@admin.callback_query(AdminProtect(), StateFilter(SetHoursStates.ChooseWaiter), F.data.startswith("SH_WAITER|"))async def sh_choose_waiter(query: CallbackQuery, state: FSMContext):    _, tg = query.data.split("|", 1)    await state.update_data(selected_tg=int(tg))    today = datetime.today()    kb = make_calendar(today.year, today.month, set())    await state.set_state(SetHoursStates.ChooseDate)    await query.message.edit_text("Выберите дату смены:", reply_markup=kb)@admin.callback_query(AdminProtect(), StateFilter(SetHoursStates.ChooseDate), F.data.startswith("CAL_DAY|"))async def sh_choose_date(query: CallbackQuery, state: FSMContext):    _, date_str = query.data.split("|", 1)    await state.update_data(shift_date=date_str)    await state.set_state(SetHoursStates.InputStartTime)    m = await query.message.edit_text(f"Дата: {date_str}\nВведите время начала смены (HH:MM):")    await state.update_data(prompt_id=m.message_id)@admin.message(AdminProtect(), StateFilter(SetHoursStates.InputStartTime))async def sh_input_start(message: Message, state: FSMContext):    data = await state.get_data()    await _safe_delete_message(message.bot, message.chat.id, data.get("prompt_id"))    try:        start_t = datetime.strptime(message.text.strip(), "%H:%M").time()    except ValueError:        await message.reply("Неверный формат, используйте ЧЧ:ММ")        return    await state.update_data(start_time=start_t, user_msg_id=message.message_id)    await state.set_state(SetHoursStates.InputEndTime)    m = await message.answer("Введите время окончания смены (HH:MM):")    await state.update_data(prompt_id=m.message_id)@admin.message(AdminProtect(), StateFilter(SetHoursStates.InputEndTime))async def sh_input_end(message: Message, state: FSMContext):    data = await state.get_data()    for mid in (data.get("prompt_id"), data.get("user_msg_id")):        await _safe_delete_message(message.bot, message.chat.id, mid)    try:        end_t = datetime.strptime(message.text.strip(), "%H:%M").time()    except ValueError:        await message.reply("Неверный формат, используйте ЧЧ:ММ")        return    dt0 = datetime.combine(datetime.today(), data["start_time"])    dt1 = datetime.combine(datetime.today(), end_t)    if dt1 < dt0:        dt1 += timedelta(days=1)    hrs = (dt1 - dt0).total_seconds() / 3600    waiter_id = get_waiter_by_tg(data["selected_tg"])[0]    add_shift(waiter_id, data["shift_date"])    set_shift_hours(waiter_id, data["shift_date"], hrs)    await message.answer(        f"Смена {data['shift_date']}: {hrs:.2f} ч сохранена.", reply_markup=KB_BACK_MENU    )    await state.clear()# ─────────────────────────────────────────────#   EDIT SCHEDULE block (complete)# ─────────────────────────────────────────────@admin.callback_query(AdminProtect(), F.data == "AM_CALC_SALARY")async def calc_salary(query: CallbackQuery):    """    Считает зарплату.    * tg_id 2015462319 → 180 руб/час    * остальные        → HOURLY_RATE (default 140)    """    default_rate = float(os.getenv("HOURLY_RATE", "140"))    vip_tg_id    = 2015462319    # узнаём имя официанта с этим tg_id    vip_row = sqlite_db.get_waiter_by_tg(vip_tg_id)    vip_name = vip_row[1] if vip_row else None    total_all = 0.0    text = "<b>Расчёт зарплаты</b>\n\n"    # группируем смены по имени    shifts_by_name: dict[str, list[tuple[str, float]]] = {}    for name, date, hrs, _ in get_all_shifts():        if hrs is None:            continue        shifts_by_name.setdefault(name, []).append((date, hrs))    for name, person_shifts in shifts_by_name.items():        rate = 180 if (vip_name and name == vip_name) else default_rate        subtotal = 0.0        text += f"<u>{name or 'Без имени'}</u>\n"        for date, hrs in person_shifts:            line, pay = _format_payline(date, hrs, rate)            text += line + "\n"            subtotal += pay        text += f"➡️ <b>Итого: {subtotal:.2f}</b>\n\n"        total_all += subtotal    text += f"<b>Общая сумма к выплате: {total_all:.2f}</b>"    today = datetime.today()    kb = InlineKeyboardMarkup(inline_keyboard=[        [InlineKeyboardButton(            text="🧹 Очистить выплаты за месяц",            callback_data=f"AM_CLEAR_PAY|{today.year}|{today.month:02d}"        )],        [InlineKeyboardButton(text="⏪ В меню админа", callback_data="AM_BACK_MENU")],    ])    await query.message.edit_text(text, parse_mode="HTML", reply_markup=kb)@admin.callback_query(AdminProtect(), StateFilter(EditSchedStates.ChooseDate), F.data.startswith("CAL_NEXT|"))async def es_next_month(query: CallbackQuery, state: FSMContext):    data = await state.get_data()    y, m = data["edit_year"], data["edit_month"] + 1    if m == 13:        y, m = y + 1, 1    marked = {row[1] for row in get_all_shifts()}    kb = make_calendar(y, m, marked)    await state.update_data(edit_year=y, edit_month=m)    await query.message.edit_text("Изменить график: выберите дату", reply_markup=kb)# ─────────────────────────────────────────────#   EDIT SCHEDULE  (AM_EDIT_SCHEDULE)# ─────────────────────────────────────────────@admin.callback_query(AdminProtect(), F.data == "AM_EDIT_SCHEDULE")async def es_start(query: CallbackQuery, state: FSMContext):    """Старт: показать календарь текущего месяца с отмеченными сменами."""    today = datetime.today()    marked = {row[1] for row in get_all_shifts()}    kb = make_calendar(today.year, today.month, marked)    kb.inline_keyboard.append(        [InlineKeyboardButton(text="⏪ В меню админа", callback_data="AM_BACK_MENU")]    )    await state.set_state(EditSchedStates.ChooseDate)    await state.update_data(edit_year=today.year, edit_month=today.month)    await query.message.edit_text(        "Изменить график: выберите дату",        reply_markup=kb,    )# ───── навигация по месяцам ─────@admin.callback_query(    AdminProtect(), StateFilter(EditSchedStates.ChooseDate), F.data.startswith("CAL_PREV|"))async def es_prev_month(query: CallbackQuery, state: FSMContext):    _, y, m = query.data.split("|")    y, m = int(y), int(m) - 1    if m == 0:        y, m = y - 1, 12    marked = {row[1] for row in get_all_shifts()}    kb = make_calendar(y, m, marked)    kb.inline_keyboard.append(        [InlineKeyboardButton(text="⏪ В меню админа", callback_data="AM_BACK_MENU")]    )    await state.update_data(edit_year=y, edit_month=m)    await query.message.edit_text("Изменить график: выберите дату", reply_markup=kb)@admin.callback_query(    AdminProtect(), StateFilter(EditSchedStates.ChooseDate), F.data.startswith("CAL_NEXT|"))async def es_next_month(query: CallbackQuery, state: FSMContext):    _, y, m = query.data.split("|")    y, m = int(y), int(m) + 1    if m == 13:        y, m = y + 1, 1    marked = {row[1] for row in get_all_shifts()}    kb = make_calendar(y, m, marked)    kb.inline_keyboard.append(        [InlineKeyboardButton(text="⏪ В меню админа", callback_data="AM_BACK_MENU")]    )    await state.update_data(edit_year=y, edit_month=m)    await query.message.edit_text("Изменить график: выберите дату", reply_markup=kb)# ───── очистить месяц ─────@admin.callback_query(    AdminProtect(),    StateFilter(EditSchedStates.ChooseDate),    F.data == "AM_CLEAR_SCHEDULE",)async def es_clear_month(query: CallbackQuery, state: FSMContext):    data = await state.get_data()    y, m = data["edit_year"], data["edit_month"]    cur = get_cursor()    cur.execute("DELETE FROM shifts WHERE date LIKE ?", (f"{y:04d}-{m:02d}-%",))    sqlite_db.base.commit()    await query.answer(f"График за {y}-{m:02d} очищен", show_alert=True)    kb = make_calendar(y, m, set())    kb.inline_keyboard.append(        [InlineKeyboardButton(text="⏪ В меню админа", callback_data="AM_BACK_MENU")]    )    await query.message.edit_text("Изменить график: выберите дату", reply_markup=kb)# ───── дата выбрана ─────@admin.callback_query(    AdminProtect(),    StateFilter(EditSchedStates.ChooseDate),    F.data.startswith("CAL_DAY|"),)async def es_choose_date(query: CallbackQuery, state: FSMContext):    _, selected = query.data.split("|", 1)    await state.update_data(edit_date=selected)    # список официантов    buttons = [        [            InlineKeyboardButton(                text=get_waiter_by_tg(tg)[1] or str(tg),                callback_data=f"ES_WAITER|{tg}",            )        ]        for tg in get_all_waiters()    ]    kb = InlineKeyboardMarkup(inline_keyboard=buttons)    kb.inline_keyboard.append(        [InlineKeyboardButton(text="⏪ Отмена", callback_data="AM_EDIT_SCHEDULE")]  # вернуться к календарю    )    await state.set_state(EditSchedStates.ChooseWaiter)    await query.message.edit_text(f"Дата: {selected}\nВыберите сотрудника:", reply_markup=kb)# ───── отмена из календаря ─────@admin.callback_query(    AdminProtect(),    StateFilter(EditSchedStates.ChooseDate),    F.data == "CAL_CANCEL",)async def es_cancel_edit(query: CallbackQuery, state: FSMContext):    await state.clear()    await admin_menu(query.message, state)# ───── официант выбран ─────@admin.callback_query(AdminProtect(), F.data.startswith("ES_WAITER|"))async def es_select_waiter(query: CallbackQuery, state: FSMContext):    _, tg = query.data.split("|", 1)    await state.update_data(selected_tg=int(tg))    kb = InlineKeyboardMarkup(inline_keyboard=[        [InlineKeyboardButton(text="📝 Прописать задачи", callback_data="ES_TASKS")],        [InlineKeyboardButton(text="❌ Без задач",      callback_data="ES_NO_TASKS")],    ])    kb.inline_keyboard.append(        [InlineKeyboardButton(text="⬅️ Назад", callback_data="AM_EDIT_SCHEDULE")]    )    date = (await state.get_data())["edit_date"]    await state.set_state(EditSchedStates.ChooseTaskAction)    await query.message.edit_text(        f"{date} — {get_waiter_by_tg(int(tg))[1]}",        reply_markup=kb,    )# ───── «без задач» ─────@admin.callback_query(AdminProtect(), F.data == "ES_NO_TASKS")async def es_no_tasks(query: CallbackQuery, state: FSMContext):    data = await state.get_data()    wid  = get_waiter_by_tg(data["selected_tg"])[0]    add_shift(wid, data["edit_date"])    await query.message.edit_text("Задач нет. График обновлён.", reply_markup=KB_BACK_MENU)    await state.clear()# ───── ввод списка задач ─────@admin.callback_query(AdminProtect(), F.data == "ES_TASKS")async def es_enter_tasks(query: CallbackQuery, state: FSMContext):    await state.set_state(EditSchedStates.InputPersonalTasks)    await query.message.edit_text("Введите список задач (каждый пункт с новой строки):")@admin.message(AdminProtect(), StateFilter(EditSchedStates.InputPersonalTasks))async def es_save_tasks(message: Message, state: FSMContext):    data = await state.get_data()    wid = get_waiter_by_tg(data["selected_tg"])[0]    add_shift(wid, data["edit_date"])    set_shift_tasks(wid, data["edit_date"], message.text.strip())    await message.answer("Задачи сохранены.", reply_markup=KB_BACK_MENU)    await state.clear()# ----- back menu button -----@admin.callback_query(AdminProtect(), F.data == "AM_BACK_MENU")async def es_back(query: CallbackQuery, state: FSMContext):    await admin_menu(query.message, state)    await _safe_delete_message(query.bot, query.message.chat.id, query.message.message_id)# ─────────────────────────────────────────────#   SALARY# ─────────────────────────────────────────────@admin.callback_query(AdminProtect(), F.data == "AM_CALC_SALARY")async def calc_salary(query: CallbackQuery):    default_rate = float(os.getenv("HOURLY_RATE", "140"))   # ставка по-умолчанию    total_all = 0.0    text = "<b>Расчёт зарплаты</b>\n\n"    # группируем смены по имени    shifts_by_name: dict[str, list[tuple[str, float]]] = {}    for name, date, hrs, _ in get_all_shifts():        if hrs is None:            continue        shifts_by_name.setdefault(name, []).append((date, hrs))    for name, person_shifts in shifts_by_name.items():        # --- персональная ставка ---        rate = 180 if (name and name.lower() == "Константин") else default_rate        subtotal = 0.0        text += f"<u>{name or 'Без имени'}</u>\n"        for date, hrs in person_shifts:            line, pay = _format_payline(date, hrs, rate)            text += line + "\n"            subtotal += pay        text += f"➡️ <b>Итого: {subtotal:.2f}</b>\n\n"        total_all += subtotal    text += f"<b>Общая сумма к выплате: {total_all:.2f}</b>"    today = datetime.today()    kb = InlineKeyboardMarkup(inline_keyboard=[        [InlineKeyboardButton(            text="🧹 Очистить выплаты за месяц",            callback_data=f"AM_CLEAR_PAY|{today.year}|{today.month:02d}"        )],        [InlineKeyboardButton(text="⏪ В меню админа", callback_data="AM_BACK_MENU")],    ])    await query.message.edit_text(text, parse_mode="HTML", reply_markup=kb)@admin.callback_query(AdminProtect(), F.data.startswith("AM_CLEAR_PAY|"))async def clear_pay(query: CallbackQuery, state: FSMContext):    _, y, m = query.data.split("|", 2)    cur_local = get_cursor()    cur_local.execute("UPDATE shifts SET hours=NULL WHERE date LIKE ?", (f"{y}-{m}-%",))    sqlite_db.base.commit()    await query.answer("Часы за месяц обнулены!", show_alert=True)    await admin_menu(query.message, state)# ─────────────────────────────────────────────#   NOTIFY & EXPORT# ─────────────────────────────────────────────@admin.callback_query(AdminProtect(), F.data == "AM_NOTIFY")async def notify(query: CallbackQuery):    await query.message.edit_text("Оповещение отправлено.", reply_markup=KB_BACK_MENU)async def notify(query: CallbackQuery):    """    Шлём всем официантам сигнал, что график изменён.    """    for tg in sqlite_db.get_all_waiters():        try:            await query.bot.send_message(                tg,                "ℹ️ График был изменён! Посмотрите новую смену командой /menu.",            )        except Exception:            # бот не может написать (возможно, пользователь не начал диалог)            continue    await query.answer("Уведомления отправлены ✅", show_alert=True)    await query.message.edit_reply_markup(reply_markup=KB_BACK_MENU)@admin.callback_query(AdminProtect(), F.data == "AM_EXPORT")async def export_schedule(query: CallbackQuery):    wb = Workbook()    ws = wb.active    ws.append(["Сотрудник", "Дата", "Часы", "Задачи"])    for name, date, hrs, tasks in get_all_shifts():        ws.append([name, date, hrs, tasks])    buf = BytesIO()    wb.save(buf)    buf.seek(0)    await query.message.answer_document(FSInputFile(buf, filename="schedule.xlsx"), reply_markup=KB_BACK_MENU)